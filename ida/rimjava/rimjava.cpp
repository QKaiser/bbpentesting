#include <windows.h>
#include "../idaldr.h"
#include <string>
#include <map>
#include <struct.hpp>
#include <nalt.hpp>
#include <demangle.hpp>
#include "rim_struct.h"
#include "rim_namedecode.h"

#define COD_SIGNATURE 0xFFFFC0DE

segment_t seg_data;
segment_t seg_code;

enum eModuleFlags
{
	isLibrary=1,
	isMidlet=2,
	isSomething4=4,
	isSomething8=8,
	isSomething20=0x20,
};

#pragma pack (push,1)

struct MethodDescriptor
{
	unsigned short ClassDescOffset;
	unsigned short MethodNameOffset;
	unsigned short Unknown17;
};

struct CodHeader
{
	unsigned long Signature; //0
	unsigned long ReferencedFileIndex; //4
	unsigned long vtable_pointer; //8
	unsigned long RomFileLinkedID; //0xC
	unsigned long TimeStamp; //0x10
	unsigned long UserVersion; //0x14
	char Unknown2[4]; //0x18
	unsigned long DataFileIndex; //0x1C
	unsigned long ResourceFileIndex; //0x20
	char Unknown3[2]; //0x24
	unsigned short CodeSize; //0x26
	unsigned short DataSize; //0x28
	unsigned short ModuleFlags; //0x2a
};

struct DatHeader
{
	unsigned char Unknown1; //0
	unsigned char Unknown2; //1
	unsigned short ClassesCount; //2
	unsigned char ModulesCount; //4
	unsigned char InterfacesCount; //5
	unsigned short AppParamsOffs; //6
	unsigned short Unknown4; //8
	unsigned short Interface1Offs; //0xA
	unsigned short Interface2Offs; //0xC
	unsigned short Unknown5;
	unsigned short Unknown6;
	unsigned short ClassDescriptorArray;
	unsigned short MethodDescriptorArray;
	unsigned short Unknown7;
	unsigned short Unknown8;
	unsigned short ClassesArray;
	unsigned short ApplicationParams2;
	unsigned short PropertiesArray;
	unsigned short Unknown9;
	unsigned short ConstantsArray;
	unsigned short DataSectionSize; // 0x24
	unsigned short Unknown11; //0x26
	MethodDescriptor EntryMethod; //0x28
	unsigned short Unknown15;
	unsigned short Unknown16;
	unsigned short Unknown17;
};



struct ClassDescriptor
{
	unsigned short Index;
	unsigned short PackageName;
	unsigned short ClassName;
	unsigned short Unknown;
};
#pragma pack (pop)

void MakeRimName(ea_t Offset)
{
	doRimName(Offset+seg_data.startEA);
}

void AddClassDescriptor(ea_t Offset)
{
	ea_t DataOffset=Offset+seg_data.startEA;
	makeStruct(DataOffset,"ClassDescriptor");
	ClassDescriptor ClsDesc;
	get_many_bytes(DataOffset,&ClsDesc,sizeof(ClsDesc));

	DataOffset=seg_data.startEA+ClsDesc.ClassName;
	doRimName(DataOffset);
	char ClassName[128];
	get_true_name(DataOffset,DataOffset,ClassName,sizeof(ClassName));

	DataOffset=seg_data.startEA+ClsDesc.PackageName;
	doRimName(DataOffset);
	char PackageName[128];
	get_true_name(DataOffset,DataOffset,PackageName,sizeof(PackageName));

	char FullName[256]={0};
	qstrncat(FullName,&PackageName[1],sizeof(FullName));
	qstrncat(FullName,".",sizeof(FullName));
	qstrncat(FullName,&ClassName[1],sizeof(FullName));

	do_name_anyway(Offset+seg_data.startEA,FullName);
	
}


int accept_file(linput_t *li, char fileformatname[MAX_FILE_FORMAT_NAME], int n)
{
	if (n)
		return 0;

	if (qlsize(li) < sizeof (CodHeader))
		return false;

	CodHeader Header;
	lreadbytes(li,&Header,sizeof(Header),false);
	if (Header.Signature!=COD_SIGNATURE)
		return false;
	
	qstrncpy(fileformatname, "Research In Motion Java file", MAX_FILE_FORMAT_NAME);

	return 1;
}
//--------------------------------------------------------------------------
//
//      load file into the database.
//

void load_file(linput_t *li, ushort neflag, const char * /*fileformatname*/)
{

	

	CodHeader Header;
	lreadbytes(li,&Header,sizeof(Header),false);

	
	seg_code.sel=allocate_selector(0);
	seg_code.align=1;
	seg_code.comb=scPub;
	seg_code.startEA=0;
	seg_code.endEA=Header.CodeSize;
	add_segm_ex(&seg_code,"Code",CLASS_CODE,ADDSEG_OR_DIE);

	file2base(li,sizeof(Header),0,Header.CodeSize, FILEREG_PATCHABLE);


	ea_t data_sel=(Header.CodeSize+sizeof(Header)) >> 4;
	if ((Header.CodeSize+sizeof(Header)) % 0x10)
	{
		data_sel++;
	}

	seg_data.sel=allocate_selector( data_sel);
	seg_data.align=1;
	seg_data.comb=scPub;
	seg_data.startEA=(data_sel << 4);
	seg_data.endEA=seg_data.startEA+Header.DataSize;

	int DSreg=str2reg("DS");
	SetDefaultRegisterValue(&seg_data,DSreg,seg_data.sel);

	add_segm_ex(&seg_data,"Data",CLASS_DATA,ADDSEG_OR_DIE);
	file2base(li,Header.CodeSize+sizeof(Header), seg_data.startEA, seg_data.endEA, FILEREG_PATCHABLE);

	LoadStructures();

	//data structures
	makeStruct(seg_data.startEA,"DataHeader_s");

	DatHeader DataHeader;
	get_many_bytes(seg_data.startEA,&DataHeader,sizeof(DataHeader));

	ea_t DataOffset=seg_data.startEA+sizeof(DatHeader);
	set_name(DataOffset,"Interfaces");
	for (int i=0;i<DataHeader.InterfacesCount;i++)
	{
		doWord(DataOffset,1);
		set_offset(DataOffset,0,seg_data.startEA);
		DataOffset+=2;
	}

	set_name(DataOffset,"Modules");
	for (int i=0;i<DataHeader.ModulesCount;i++)
	{
		doWord(DataOffset,1);
		set_offset(DataOffset,0,seg_data.startEA);
		make_ascii_string(get_word(DataOffset)+seg_data.startEA,0,ASCSTR_C);
		DataOffset+=2;
	}

	set_name(DataOffset,"Versions");
	for (int i=0;i<DataHeader.ModulesCount;i++)
	{
		doWord(DataOffset,1);
		set_offset(DataOffset,0,seg_data.startEA);
		make_ascii_string(get_word(DataOffset)+seg_data.startEA,0,ASCSTR_C);
		DataOffset+=2;
	}

	set_name(DataOffset,"ThisModuleName");
	doWord(DataOffset,1);
	set_offset(DataOffset,0,seg_data.startEA);
	make_ascii_string(get_word(DataOffset)+seg_data.startEA,0,ASCSTR_C);

	//Class descriptors
	DataOffset=DataHeader.ClassDescriptorArray+seg_data.startEA;
	set_name(DataOffset,"ClassDescriptorArray");
	int class_desc_count=(DataHeader.MethodDescriptorArray-DataHeader.ClassDescriptorArray)/sizeof(ClassDescriptor);

	DataOffset=DataHeader.ClassDescriptorArray;

	for (i=0;i<class_desc_count;i++)
	{
		AddClassDescriptor(DataOffset);
		DataOffset+=sizeof(ClassDescriptor);
	}


	//Methods descriptors
	DataOffset=seg_data.startEA+DataHeader.MethodDescriptorArray;
	set_name(DataOffset,"MethodDescriptors");
	int methods_count=get_word(DataOffset);
	doWord(DataOffset,1);
	DataOffset+=2;
	for (i=0;i<methods_count;i++)
	{
		makeStruct(DataOffset,"MethodDescriptor");
		MethodDescriptor MtdDesc;
		get_many_bytes(DataOffset,&MtdDesc,sizeof(MtdDesc));
		MakeRimName(MtdDesc.MethodName);

		char ClassName[256];
		get_true_name(MtdDesc.ClassDescriptor+seg_data.startEA,MtdDesc.ClassDescriptor+seg_data.startEA,ClassName,sizeof(ClassName));

		char MethodName[128];
		get_true_name(MtdDesc.MethodName+seg_data.startEA,MtdDesc.MethodName+seg_data.startEA,MethodName,sizeof(MethodName));

		char FullName[512]={0};
		qstrncat(FullName,ClassName,sizeof(FullName));
		qstrncat(FullName,"::",sizeof(FullName));
		qstrncat(FullName,&MethodName[1],sizeof(FullName));

		do_name_anyway(DataOffset,FullName);

		DataOffset+=sizeof(MethodDescriptor);
	}

	//Classes
	DataOffset=DataHeader.ClassesArray+seg_data.startEA;
	set_name(DataOffset,"Classes");
	int classes_count=get_word(DataOffset);
	doWord(DataOffset,1);
	DataOffset+=2;
	for (i=0;i<classes_count;i++)
	{
		doWord(DataOffset,1);
		set_offset(DataOffset,0,seg_data.startEA);
		DataOffset+=2;
	}

	



}

//----------------------------------------------------------------------
bool idaapi init_loader_options(linput_t*)
{
	msg("init_loader_options\n");
	set_processor_type("ARM", SETPROC_ALL|SETPROC_FATAL);

	return true;
}

//----------------------------------------------------------------------
//
//      LOADER DESCRIPTION BLOCK
//
//----------------------------------------------------------------------
loader_t LDSC =
{
	IDP_INTERFACE_VERSION,
		0,                            // loader flags
		//
		//      check input file format. if recognized, then return 1
		//      and fill 'fileformatname'.
		//      otherwise return 0
		//
		accept_file,
		//
		//      load file into the database.
		//
		load_file,
		//
		//	create output file from the database.
		//	this function may be absent.
		//
		NULL,
		//      take care of a moved segment (fix up relocations, for example)
		NULL,
		//      initialize user configurable options based on the input file.
		init_loader_options,
};
